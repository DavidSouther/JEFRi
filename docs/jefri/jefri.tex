\documentclass{article}

\usepackage{jefri}
\usepackage{hyperref}
\usepackage[underline=true,rounded corners=false]{pgf-umlsd}

\usepackage{fullpage}
\linespread{1.3}

\begin{document}

\jefri{Core Runtime}

\tableofcontents
\newpage
\linespread{1.6}

\section{Overview}

JEFRi is an entity framework. Entity Frameworks allow developers to specify data
descriptions and relationships once for their domain, then share data throughout
their application space in a unified way. JEFRi accomplishes this by specifying
an Entity Context independent of any programming language. This context
describes the entities available in the domain model, the properties of those
entities, the relationships between entities, and any additional attributes
needed to make the model suitably robust. These navigation properties allow
entities to act naturally and transparently as composite types. This allows
intelligent loading of related data, without requiring an application to load an
entire object graph.

An Entity Framework provides a wealth of functionality over a pure Object /
Relational Mapper. Straight ORMs simply translate between a database table and
an instantiated object. A full EF includes tracking modifications of entities,
descriptive methods to navigate entity relationships, intelligent sharing
between framework instances, and more. JEFRi is a specification for how to
define these entities, how to share these entities, and many other features
enabling software projects to quickly and efficiently work with their data.

\section{Entities}

Entities are independent, identifiable components of an application's model.
Entities are analogous to instances of objects in object oriented programming,
or table rows in relational databases. Entities are the building blocks of the
domain, the things the domain is modeling. Entities could be receipts in a Point
of Sale application, Clients in Contact Management System, or Planets in a
physics model. Entities within an entity framework are endowed with a variety of
backing infrastructure, including tools for sharing data between runtimes, tools
for storing data to various persistence layers, and tools for tracking the
history of the entity.

\subsection{Keys}

Every Entity must have a key --- a single unique value identifying that entity
across all instances of any runtime. To meet this requirement in a distributed,
heterogeneous environment, keys are recommended to be version 4 (random) UUIDs.
Keys are used exclusively to refer to entities of a specific type. To maintain
unique object graphs when flattening into transactions, the key is used as an
object identifier, saving the need to handle issues of using memory references
or incrementing integers as keys.

Entity keys are immutable --- once an entity has been instantiated, its key must
not change. Anything that could cause a change in a key must instead create a
new entity instance.

Keys should be generated by whichever runtime initially creates a new instance
of an entity. Thus, it is important that JEFRi instances provide suitably robust
random number generators. By having the key assigned by the runtime that first
creates an entity, applications eliminate the need for a central repository of
canonical key information. Without a central key store, applications can be free
to handle concurrency with whatever mechanism best fits the domain model.
Further, since applications don't need to synchronize keys, significant
reductions in bandwidth are seen. The concern of conflicting keys is mitigated
by choosing a sufficiently large key domain. Further, keys must only be unique
to entity types. Thus, randomly generating Version 4 UUIDs allows 6 million
billion keys per entity type before reaching a 50\% chance of a single collision
amongst keys in a single entity type.

We will see later that an entity's full URI within a runtime is technically
{\ilcode entity://\-application/\-context/\-type/\-uuid}, so it is arguable that
UUIDs are ``Too Much". Then again, no one needs more than 640K. If a context
expects more entities of some type than this, it would be simple to replace the
key generator implementation with something more suitably robust for that
application.

\subsection{Properties}

Properties are the non-independent pieces of data that describe an entity. These
are the columns in a table, or the fields of an object. Properties of an entity
have a variable {\ilcode name}, a {\ilcode type}, and optional {\ilcode
attributes}. The name is the identifier that will be used throughout the JEFRi
runtimes. Allowed types are {\ilcode int}, for a finite whole-number (possibly
negative) value; {\ilcode float}, for a decimal floating-point number with at
least 32 bits of machine precision; {\ilcode boolean}, for data that can have a
value of {\ilcode true} or {\ilcode false}; and {\ilcode string}, a list of zero
or more character values. Within a runtime, the types may be represented however
makes most sense for that platform. When transferring data between runtimes,
property values should be transmitted using JSON definitions for values.

\subsection{Relationships}

Relationships describe how entities interact with and reference other entities.
This allows developers to write very natural expressions when moving between
data records. Data modelers are able to describe what these connections are
called, how the relate to one-another, and all the details needed to completely
automate loading and navigating the entity graph.

There are two basic forms of relationships --- {\ilcode has\_a} and {\ilcode
has\_many}. A third type, {\ilcode is\_a}, is a specialized {\ilcode has\_a}
with no possible return relationship. {\ilcode has\_a} states that an entity
references one and exactly one other entity. {\ilcode has\_many} states that an
entity references several entities of some type. Using these relationship
primitives, a

When an application has an instantiated entity, relationships can be navigated
by calling the appropriate {\ilcode get\_`navprop'} method of the entity. For
example, if a Receipt has an associated Client, you could call {\ilcode
receipt.get\_client()} which would return a single Client. Conversely, from the
client end, you could call {\ilcode client.get\_receipts()} to return an array
of Receipt entities. Notice how the navigation methods are properly pluralized.
This is a result of naming the relationships {\ilcode user} and {\ilcode
receipts} in the context- it is not the runtime's responsibility to handle
pluralities, but the context generator's.

\section{Contexts}

JEFRi Contexts are descriptions of the entity model. Contexts are described here
as JSON objects, though can be any persistable object serialization.  A context
should have a globally unique URI for identification. Contexts published in this
way can then be referenced by entity descriptions in other contexts. As an
example, a human resources department in an organization could define a context
describing the employees of a company. The Information Systems team would then
write a context defining their technology tools and include the HR context
directly, creating a clean interface between the departments.

\subsection{Context Specification}

A context specification is an object with two properties --- {\ilcode
attributes}, describing the context specific options, and {\tt entities}, an
array of entity descriptions.

A context's {\ilcode attribute} is an object containing arbitrary keyed data for
a runtime's consumption. For example, an {\ilcode attribute} could declare
{\ilcode persistOnUpdate} to be true. In this case, the runtime could then
automatically attempt to persist an entity any time its properties were updated.
The list of canonical {\ilcode attribute} keys and their meaning will grow
organically as JEFRi is fleshed out. Otherwise, the documentation for a
particular implementation must specify the specific attributes it handles, as
well as their meanings. Many JEFRi extensions will define some attributes,
allowing runtimes to choose which extensions to handle, as needed.

The {\ilcode entities} array is the heart of the context. Each entry describes
one entity type available. The entries are objects with five keys. Those are
{\ilcode name}, the canonical name for the entity type; {\ilcode key}, the
property containing the entity's UUID; {\ilcode properties}, an array containing
the properties of the entity; {\ilcode relationships}, an array containing
descriptions of the various navigation properties; and {\ilcode attributes}, an
object describing various metadata about the entity itself.

{\ilcode name} is the canonical type name for an entity. It is used extensively
to look up property definitions from several points in the application,
especially when creating new entities, persisting entities, and navigating
entity relationships. Entity names must be unique within a context. Entity names
must be valid Javascript object keys --- {\ilcode $=\sim$
/[a-zA-Z\_\$][a-zA-Z0-9\_\$]*/}

{\ilcode key} is the name of the property containing the entity's key. See the
section on entity keys for more details on how keys are used in JEFRi.

{\ilcode properties} is an array of objects similar in layout to entities, but
without keys or relationships. Specifically, properties must define a name, a
type, and an array of attributes. The name is the Javascript-safe property
identifier, and must be unique among the properties of an entity. The type is
the platform- agnostic datatype specifier. Canonically recognized types are
{\ilcode int}, {\ilcode float}, and {\ilcode string}.

{\ilcode attributes} is an object of arbitrary key/value pairs. Currently
recognized attributes are {\ilcode nullable} (for {\ilcode int}, {\ilcode
float}, and {\ilcode string}), allowing the field to have an appropriate value
or {\ilcode null}; and {\ilcode length} (for {\ilcode string}, specifying the
maximum number of characters. Again, it is the runtime implementor's
responsibility to document recognized attributes and their behavior.

{\ilcode relationships} is an array describing the various navigation properties
available to an entity. A relationship has four keys --- {\ilcode name}, the
identifier for the navigation; {\ilcode type}, one of {\ilcode is\_a}, {\ilcode
has\_a}, or {\ilcode has\_many}; {\ilcode property}, the entity property to
define the relationship; and {\ilcode to}, describing the second entity taking
part in the relationship. {\ilcode name} must be a locally unique, valid
Javascript identifier. Further, it determines which {\ilcode get\_} method must
be called to navigate the relationship (specifically, {\ilcode
entity.get\_`name'()}). {\ilcode type} determines what will be returned when
navigating the relationship. {\ilcode has\_a} and {\ilcode is\_a} will return a
single entity, while {\ilcode has\_many} will return a (possibly empty) array of
entities. The runtime is responsible for ensuring a method with the correct
signature and appropriate semantics exists for each navigation method required.
There is some indication that the far side of a {\ilcode has\_a} or {\ilcode
has\_many} relationship will probably have a {\ilcode has\_a} or {\ilcode
has\_many} navigation that would lead back to the entity on the from side
(however, this is not a requirement). {\ilcode is\_a} will not have a reverse
navigation. JEFRi does not support the concept of casting down.

Finally, the {\ilcode property} and {\ilcode to} properties describe where to
look up the data needed for the navigation. In all relationships, the {\ilcode
to} type field {\it must} resolve to a valid entity name. The property fields
are used slightly differently depending on what the type of the relationship is.
In every relationship, {\ilcode to.property} must equal {\ilcode property}, and
the navigation method will return the one {\ilcode to.type} whose key is equal
to the {\ilcode from.property} for a {\ilcode has\_a} relationship,  or the
array of entities for a {\ilcode has\_many} relationship.

If {\ilcode attributes} at any level is empty, it may be removed from the
context. If an entity has no {\ilcode relationships}, it may be removed from the
context.

\section{Runtimes}

A JEFRi runtime is the underlying programming component which handles all
aspects of JEFRi for an application. Runtimes act as a data cache, managing
references to Entities within an application. This includes responsibilities
for interning entities, managing entity relationships, and attaching attribute
information to Entities.

Runtimes can expose themselves publicly as a REST service. These services
provide two URIs, {\ilcode http://\-example.com/\-jefri/\-{\textbf{get}}} for
handling {\ilcode get} transactions and {\ilcode
http://\-example.com/\-jefri/\-{\textbf{persist}}} for handling persist
requests. Transactions are POSTed to these URIs, and the runtime will return the
appropriate result.

\subsection{Persistence Stores}

Persistence Stores allow JEFRi applications to save their data in some fashion.
Persistence Stores use transactions as a specification for data to either store
or retrieve data. Implementations of persistence stores are flexible on how they
handle this. Some implementations might translate transactions into SQL queries,
using an underlying RDBMS configured with a JEFRi context. Other implementations
can send transactions to remote public JEFRi runtimes, acting as a proxy between
runtimes. Applications could use these stores to create a traditional client /
server model, or build a flexible peer-to-peer model for data communication.

Persistence stores must provide a single function {\ilcode execute} which
takes a transaction and returns an object encapsulating a callback on an
asynchronous operation. While a persistence store that operates locally could
return immediately, to ensure consistency across runtime implementations the
store must return a callback handler.

Executing {\ilcode get} transactions must handle the myriad of filter and join
operations available in the transaction specifications. See the section on
transaction specifications for the exact semantics of get requests.  Executing
{\ilcode persist} transactions must function atomically.  It is the
responsibility of the remote runtime to ensure that transactions happen
atomically. In general, it is the persistence store's responsibility to meet the
semantics specified in the section on Transactions.

\section{Transactions}

The most important, fundamental concept in computer programing is the word-level
atomic write. Since the first computers, it was impossible to read an
inconsistent word of memory- if a read and a write occur {\sl simultaneously},
the read will either return the value in memory BEFORE the write, or the value
in memory AFTER the write. It will NEVER return some of the before and some of
the after bits. At a hardware level, this only works with the smallest
addressable batch of memory --- a word. Since entities are probably always going
to be bigger than a single word (integer UUIDs alone are 2 full words on a
64-bit machine), it is not possible to achieve atomic entity persistence in
hardware alone. It is still necessary to have guaranteed atomic writes for
entity data.

JEFRi transactions fill this gap. When a runtime is ready to persist a batch
of entity updates, it builds a serializable object representation of just the
pieces that need to be updated. By using entity keys extensively, the runtime
can flatten the object graph into an object list, with guaranteed unique
references between the entities. This transaction detail can then be sent
between runtime instances, with some guarantee that that information is
consistent (generally, that guarantee will come from TCP).

JEFRi has two transaction types: {\ilcode get} and {\ilcode persist}. A {\ilcode
get} transaction is used to request data from a remote, public JEFRi runtime. A
{\ilcode persist} transaction is used to update data at a remote, public JEFRi
runtime. Transactions are a serialized object with two properties: {\ilcode
attributes}, describing the transaction; and {\ilcode entities}, describing the
entities to deal with.

In a {\ilcode get} transaction, the entities array is a template for which
entities should be returned. The return transaction will contain all entities
that meet the criteria specified in the transaction. Specifically, the remote
instance will look at the first object in the transaction. It will return all
entities of that type whose properties match the given properties. It will join
specified navigation properties (using just {\ilcode `name'}, not {\ilcode
get\_`name'}). It will do this for each entity in the array. In other words, the
individual entities specify AND conditions, while the multiple entities specify
OR conditions.

In a {\ilcode persist} transaction, the entities array has the literal data that
must be persisted. The remote JEFRi runtime is responsible for making the
persist atomic and returning a transaction filling in the additional or updated
details it has about these entities that was not included in the original
transaction (eg, a JEFRi instance may persist an entity to a runtime using DB2
as a backend, where one property has an update trigger setting the timestamp to
`now' --- the reply transaction would include the updated value for that
property).

\subsection{Transaction Specifications}

Data for a transaction should be described as close to the domain model as
possible. However, requiring only full entities would result in more verbose
transactions than necessary. To that end, the specification to a transaction
will be an array of objects describing the entities in the transaction. The
format for a transaction is an object with properties {\ilcode attributes} and
{\ilcode entities}. {\ilcode attributes} is an object. {\ilcode entities} is an
array of entity objects. Entity objects must specify at least one field,
{\ilcode \_type}. Additional fields are dependent on entity properties and
relationships.

The values in those additional fields are different between {\ilcode get}
transactions and {\ilcode persist} transactions. In a {\ilcode get} transaction,
values for property keys specify the conditions necessary for an entity to be
included in the transaction's result. Values for relationship keys are objects
that describe which of the relationship entities to return. If a {\ilcode get}
transaction specifies criteria for a relationship entity, there must be matching
entities in the relationship to return any entities. In a {\ilcode persist}
transaction, values for each property specify the new value for that entity.
Relationship keys are forbidden; to persist entities and their relationships,
the property containing the relationship key value should be sent, along with
the update relationship entity.

\linespread{1}
\begin{lstlisting}
{attributes:{}
entities: [{
	_type: 'User',
	surname: 'Franken',
	prop2: value2,
	cards: {}
}]}
\end{lstlisting}
\linespread{1.6}

If this were a {\ilcode get} transaction, the reply would have an array of
entities of {\ilcode User} and {\ilcode Card}, with all the {\ilcode User}
entities having {\ilcode surname = `Franken', prop2 = value2}, and all the
{\ilcode Card}s correctly associated with the matched Users.  Navigation
property objects can specify constraints on the nav properties returned, and
can themselves declare navigation properties to return. It is not necessary to
specify a type in a navigation property --- any that are will be ignored.

If this were a {\ilcode persist} transaction, the {\ilcode key} property {\it
must} be included. The persistent store would update (or store) the values of
the entity with the properties passed in. To save navigation properties, each
entity that is part of the navigation should be added individually.

\subsubsection{Gory Get Details}

To capture the full expressiveness developers need in describing data, there are
several rules transactions will use to determine the entities to return from a
{\ilcode get} transaction.

If the property is the entity key, it will be converted to an appropriate format
for the store, and the property must match exactly. While the UUID can be
transmitted as a hex string, it is recommended to transmit it as a 16-byte
integer when possible, to conserve space.

If value is an integer, properties must match exactly.

If value is a float, either it should be matched at a $2^{-8}$ threshold or it
can be the first number of an array tuple, whose second parameter specifies the
threshold precision as an integer $n$ such that the threshold is $2^{-n}$.

If the value is a string, it will be treated as an SQL LIKE operation. Returned
entities will have properties whose values contain the string (case sensitive).

If the value is an array, the first field in the array may specify an operation,
may be a floating point number (see above), may be a compound filter, or may be
an enumeration of values the field's value must be {\ilcode in}.

Valid operations are any of {\ilcode $<$}, {\ilcode $<=$}, {\ilcode $>$},
{\ilcode $>=$}, {\ilcode $=$}, and {\ilcode REGEX}. {\ilcode REGEX} treats the
next value as a PCRE regular expression, and any returned entities will have
that property matching the regex. Otherwise, the operations are as specified by
the store, but generally should be numerical ordering for numbers, and
lexicographical ordering for strings.

%SUM? AVERAGE? COUNT? MAX? MIN?

%GROUP BY?

If the value is an array whose first parameter is not an operator or another
array, the returned entity's property will match as an IN clause, with integers
matching exactly and string matching as described above.

If the first parameter is an array, then each element of the value's array is
treated as an ANDed where clause, with the components of sub arrays following
the same (value) or (operator, value) rules presented here.

Using a common SQL driver,
\linespread{1}
\begin{lstlisting}
[{
	_type: `User',
	surname: `Franken',
	date_of_birth: [
		[`<=', 1200000000],
		[`>=', 1100000000]
	],
	cards: {}
}]
\end{lstlisting}
\linespread{1.6}

becomes

\linespread{1}
\lstset{language=SQL}
\begin{lstlisting}
SELECT
	User.user_id AS user.user_id,
	User.surname AS user.surname,
	User.given_name AS user.given_name,
	User.login AS user.login,
	User.date_of_birth AS user.date_of_birth,
	Card.card_id AS card.card_id,
	Card.user_id AS card.user_id,
	Card.name AS card.name,
	Card.email AS card.email,
	Card.phone AS card.phone,
	Card.address AS card.address,
	Card.city AS card.city,
	Card.state AS card.state,
	Card.postal AS card.postal,
	Card.country AS car.country,
FROM USER
JOIN Card on User.user_id = Card.card_id
WHERE
	User.surname LIKE `%Franken%'
	AND User.date_of_birth <= 1200000000
	AND User.date_of_birth >= 1100000000
\end{lstlisting}
\lstset{language=JavaScript}
\linespread{1.6}

Since this is a join and there are no constraints on {\ilcode Card}, this
query will return a number of rows equal to the total number of matched cards.
With more than one contact card per {\ilcode User}, some of the User data will
be duplicated. The runtime the store is running in must intern all the instances
of the different {\ilcode Users}, so there will be no duplicated entity
instances in memory.

\subsection{Best Persist Practices}

Persist transactions are an application's way to send changed entities to
another runtime. For a database-backed entity store, these transactions could
return quickly. For a store that has to post the transaction to a remote host,
the persist might take much longer. To unify the interface, all transactions are
asynchronous, and return a deferred promise\footnote{For a full explanation of
deferreds and their promises, see the
\href{http://api.jquery.com/category/deferred-object}{jQuery documentation}
--- jQuery has the most complete and
robust deferred implementations today.}. With this in mind, there are three
separate techniques or approaches to handling a persist transaction.

The first approach is managing the transaction directly. The application readies
a transaction by calling {\ilcode ec.transaction()}. The application can then
add a number of entities to the transaction via {\ilcode
transaction.add(entity)}. Finally, the application should call {\ilcode
transaction.persist()} to persist and finalize the request. The same entity can
be added multiple times without being duplicated in the final send.

The second is persisting the changes to a single entity. Every entity has a
function {\ilcode persist()}. This function will generate several events,
including {\ilcode entity.persisting(entity, transaction)}, passing in the
transaction that will handle the persist request. The entity should use this to
add related data to the transaction. This technique can be combined effectively
with the first approach.

The final technique is a pair of helper methods in the EntityContext itself. The
EC maintains an internal record of what entities have been changed, and what
entities have been added. The two methods {\ilcode ec.persist\_new()} and
{\ilcode ec.persist\_changes()} can be used to easily persist all entities that
have been created or modified, but not persisted, respectively.

\subsection{Entity Accounting}

To facilitate minimizing data transfer, entities and the EntityContext keep
track of changes that occur during runtime. The EntityContext maintains an array
of new entities and an array of modified entities. These can be used to quickly
index what needs to be sent in {\ilcode persist\_changes} or {\ilcode
persist\_new}.

Entities maintain accounting information regarding their status. This is stored
in two properties and a function.

{\ilcode \_\_new} Boolean property, set to true if this is a new entity.

{\ilcode \_\_modified} Object whose keys are property names that have been
updated, and those values are the value when the object was last persisted (or
the default value, if the entity is new). When an property of an entity is set,
the entity should check in its {\ilcode \_\_modified} object for the property.
If the property is not in \_\_modified, set {\ilcode \_\_modified[property]} to
the current value of {\ilcode entity[property]}, update {\ilcode
entity[property]}, and add itself to the EntityContext's {\ilcode \_modified}
list. If the property {\it  is} in {\ilcode \_\_modified}, and the value in
{\ilcode \_\_modified} is the same as the setter's value, then the entity should
set its property and remove the property from \_\_modified. If that was the last
property in \_\_modified, the entity should remove itself from the
EntityContext's modified list.

{\ilcode \_status()} Is a function returning one of {\ilcode NEW}, {\ilcode
MODIFIED}, or {\ilcode PERSISTED}. An entity is in the {\ilcode NEW} state if it
has been created, but never taken part in a {\ilcode persist} transaction. An
entitiy is {\ilcode MODIFIED} if it has been successfully persisted in the past,
but has had a property modified and not reset since the last persist. An entity
is {\ilcode PERSISTED} if it has been part of a successful persist transaction,
and has not had any of its property values updated, or all its property have
been set to their last persisted values.

Every entity has a default {\ilcode persisted} event handler that clears the
modified object, clears the new flag, and removes the entity from the
EntityContext's new and modified arrays.

\section{API}

Runtime Methods are called on an instance of a JEFRi runtime, and include many
data access routines. Entity methods are called on instances of entities, and
include primarily navigation properties, as well as entity-specific persistence
methods. Transaction methods are called on a class which manages {\ilcode get}
and {\ilcode persist} transactions. Data Store methods mirror Transaction
methods, but are generally only called from the transaction. However, there is
no formal `user-mode' constraints, so that is a recommendation, not a
requirement.

\subsection{Runtime}
Runtime methods are provided as-is by a particular runtime implementation.

\subsubsection{Constructor}
\method{Runtime}{URI, options}{Runtime}
{Creates a new runtime whose primary context will be loaded from the URI given}
	{
		\param{URI}{The URI for the context description.}
		\param{options}{An object containing override parameters. Specific
			options should be detailed by the individual runtime
			implementations.}
		\returns{A reference to the newly-instantiated runtime.}
	}
\subsubsection{Methods}
\method{definition}{type}{entity\_definition}
	{Returns the context's definition for the specified type.}
	{
		\param{type}{String type of an object; either the short name within the
			primary context, the medium name within an extended context, or a
			complete name with a full context type URI.}
		\returns{An object with the entity's type definition.}
	}

\method{build}{type, obj}{Entity}
	{Return an non-interned instance of {\ilcode type} with properties
	filled in from {\ilcode obj}.}
	{
		\param{type}{String type to apply prototypes to.}
		\param{obj}{Object with default values for the entity.}
		\returns{A reference to the newly-created entity.}
	}

\method{intern}{Entity, updateOnIntern=false}{Runtime}
	{Returns a canonical instance of the {\ilcode entity} from memory. Use this
	to translate between UUIDs and pointers (or similar machine references). If
	the boolean {\ilcode updateOnIntern} is true, and there is a previously
	stored {\ilcode entity}, the old {\ilcode entity} will be updated with any
	non-default properties of the new entity. Otherwise, the old entity will be
	replaced.}
	{
		\param{entity}{Entity to intern.}
		\param{updateOnIntern}{Boolean (default false) to specify default
			behavior.}
		\returns{A reference to the runtime.}
	}

\method{expand}{Transaction}{Runtime}
	{Expand the results of a {\ilcode transaction} into the runtime. Intern
	where possible, and call {\ilcode add\_`name'} and {\ilcode set\_`name'
	where} appropriate.}
	{
		\param{Tranasaction}{Transaction to expand and intern each entity
			therein.}
		\returns{A reference to the runtime.}
	}

\method{save\_new}{Store}{Promise}
	{Start a transaction to persist all new entities to the given
		PersistenceStore.}
	{
		\param{Store}{Which store to save the new data to.}
		\returns{A Promise that will resolve when the execute has completed.}
	}

\method{save\_all}{Store}{Promise}
	{Start a transaction to persist all modified entities to the given
		PersistenceStore}
	{
		\param{Store}{Which store to save the new data to.}
		\returns{A Promise that will resolve when the execute has completed.}
	}

\subsubsection{Events}
\event{saving}{this}
	{Triggered when an EntityContext begins to save data.}
	{\param{this}{A reference to the entity itself.}}

\event{saved}{this}
	{Triggered when an EntityContext has finished persisting data to a remote
	runtime.}
	{\param{this}{A reference to the entity itself.}}

\subsection{Entity}
\subsubsection{Methods}
Entity methods must be created by the runtime when an entity type is read from a
context.
\\
\\
\method{id}{}{UUID}
	{Return the UUID of the object, independent of whichever property
	actually stores it.}
	{
		\returns{The UUID of the entity in the runtime's native format.}
	}

\method{\_type}{full=false}{String}
	{Returns a string of the canonical entity type.}
	{
		\param{full}{When true, return the full type including context URI
			prefix.}
		\returns{The entity type.}
	}

\method{get\_`name'}{}{Entity}
	{Follow a navigation property. If the relationship is an {\ilcode is\_a},
	return an instance of the {\ilcode to} type. If the relationship is a
	{\ilcode has\_a}, return a (possibly new) instance of the {\ilcode to} type.
	If the relationship is a {\ilcode has\_many}, return a (possibly empty)
	array of entities of the {\ilcode to} type.}
	{
		\returns{A the navigated entity, or an array of the navigated entity.}
	}

\method{set\_`name'}{to\_entity}{Entity}
	{Set the {\ilcode has\_a} navigation property. Correctly updates
	each entities' navigation property values.}
	{
		\param{to\_entity}{New entity for a {\ilcode has\_a} relationship.}
		\returns{A reference to this entity.}
	}

\method{add\_`name'}{to\_entity}{Entity}
	{Add to the {\ilcode has\_many} array.}
	{
		\param{to\_entity}{New entity to add to the {\ilcode has\_many list.}}
		\returns{A reference to this entity.}
	}

\method{encode}{}{raw object}
	{Return a stripped representation of the object that is suitable to add to
	a data structure to be stringified.}
	{
		\returns{A raw object with only the serializable parts of the entity.}
	}

\subsubsection{Events}
\event{persisting}{this, transaction}
	{Triggered during the transaction lifecycle when a transaction begins to
	persist to a remote runtime, but before the data has been sent.}
	{
		\param{this}{A reference to the entity itself.}
		\param{transaction}{The transaction that is persisting this entity.}
	}

\event{persisted}{this}
	{Triggered during the transaction lifecycle, after it has been confirmed
	that the entity was persisted in the remote runtime.}
	{\param{this}{A reference to the entity itself, with updated field values
	from the persist transaction.}}

\event{gotten}{this}
	{Triggered after an entity has been returned and interned from a {\ilcode
	get} transaction}
	{\param{this}{A reference to the entity, with properties updated from the
	values returned in the transaction.}}

\event{modify}{this, property, value}
	{Triggered when a property on this entity is updated.}
	{
		\param{this}{The entity the modification happened in.}
		\param{property}{The property name that was changed.}
		\param{value}{The new value of the property.}
	}

\subsection{Transaction}
\subsubsection{Methods}
\method{Transaction}{entities}{Transaction}
	{Constructor. Entities describes the data in the transaction. See the
	section on Transactions for details.}
	{	\param{entities}{Array of the first list of entities in the
			transaction.}
		\returns{The transaction.}
	}

\method{add}{entities}{Transaction}
	{Add these entities to the transaction.}
	{
		\param{entities}{Array of entities to add to the transaction.}
		\returns{The transaction.}
	}

\method{attributes}{values}{Transaction}
	{Specify {\ilcode attribute} values. Any attribute can be added. The remote
	runtime is responsible for specifying how it handles these values.}
	{
		\param{values}{Object of key/value meta values to set.}
		\returns{The transaction.}
	}

\method{get}{store}{Promise}
	{Run the transaction as a get transaction.}
	{
		\param{store}{Reference to the Persistence Store to get this
			transaction's data from.}
		\returns{The transaction.}
	}

\method{persist}{store}{Promise}
	{Run the transaction as a persist transaction.}
	{
		\param{store}{Reference to the Persistence Store to send this
			transaction's data to.}
		\returns{The transaction.}
	}

\subsubsection{Events}
\event{getting}{this}
	{Triggered when a {\ilcode get} transaction is ready to be sent to a remote
	runtime, but before it has been passed to the store.}
	{\param{this}{A reference to the transaction.}}

\event{gotten}{this}
	{Triggered when a {\ilcode get} transaction has been completely expanded.}
	{\param{this}{A reference to the transaction.}}

\event{persisting}{this}
	{Triggered when a {\ilcode persist} transaction is ready to be sent to a
	remote runtime, but before it has been passed to the store.}
	{\param{this}{A reference to the transaction.}}

\event{persisted}{this}
	{Triggered when a {\ilcode persist} transaction has been completely
	expanded.}
	{\param{this}{A reference to the transaction.}}

\subsection{PersistenceStore}
\subsubsection{Constructor}
\method{PersistenceStore}{URI, options}{PersistenceStore}
	{Create a new persistence store to handle JEFRi transactions.}
	{
		\param{URI}{Base URI of remote store.}
		\param{options}{Options to configure the store. Specific options must be
			defined by the store implementations.}
		\returns{The newly instantiated PersistenceStore.}
	}
\subsubsection{Methods}
\method{execute}{type, Transaction}{Promise}
	{Begin asynchronous execution of a transaction.}
	{
		\param{type}{PERSIST or GET, depending on how to handle the
			transaction.}
		\param{Transaction}{Transaction to execute against the remote store.}
		\returns{Promise of a deferred that will be resolved when
			the transcation completes.}
	}

\subsubsection{Events}
\event{sending}{type, to\_url, transaction, this}
	{Triggered when a store is about to send a transaction to a remote runtime.}
	{
		\param{type}{Either `{\ilcode get}' or `{\ilcode persist}', depending on
			the type of the transaction.}
		\param{to\_url}{URL of the remote runtime the transaction is destined
			for.}
		\param{transaction}{A reference to the actual transaction.}
		\param{this}{A reference to the store sending the transaction.}
	}

\event{sent}{type, to\_url, transaction, promise, this}
	{Triggered after the request has been sent, but before it has returned with
		any data.}
	{
		\param{type}{Either `{\ilcode get}' or `{\ilcode persist}', depending on
			the type of the transaction.}
		\param{to\_url}{URL of the remote runtime the transaction is destined
			for.}
		\param{transaction}{A reference to the actual transaction.}
		\param{promise}{A reference to the {\ilcode promise} that will resolve
			when the transaction completes.}
		\param{this}{A reference to the store sending the transaction.}
	}


\subsection{Events Lifecycle}
Throughout the lifetime of a JEFRi runtime, a variety of events are triggered
allowing application code to handle and modifying JEFRi actions in a variety of
ways.

This is the order of events fired during a PersistStore {\ilcode get} request.
There are two phases to the request, and are split between preparing the request
and getting a deferred promise for when the request returns, and when the
asynchronous request has actually completed.
\\
\\
\begin{sequencediagram}
\newthread{user}{User}
\newinst{transaction}{Transaction}
\newinst{store}{Store}
\newinst{remote}{Remote Runtime}
\newinst{events}{Event Handler}

\begin{call}{user}{get()}{transaction}{Promise}
	\mess{transaction}{getting}{events}
	\begin{call}{transaction}{execute()}{store}{Promise}
		\mess{store}{sending}{events}
		\begin{call}{store}{$<<$ajax$>>$}{remote}{Promise}
		\end{call}
		\mess{store}{sent}{events}
	\end{call}
\end{call}

\end{sequencediagram}

The {\ilcode transaction} has been prepared before hand, and the user's code
calls {\ilcode transaction.get()} to begin the request. {\ilcode get()} will
return a deferred, which will resolve after the request has completed and been
completely expanded in the local runtime.
\\
\\
\begin{sequencediagram}

\newthread{remote}{Remote Runtime}
\newinst{store}{Store}
\newinst{local}{Local Runtime}
\newinst{entity}{[Entity]}
\newinst{transaction}{Transaction}
\newinst{events}{Event Handler}
\newinst{user}{User}

\begin{call}{remote}{resolve(data)}{store}{}
	\begin{call}{store}{expand(data)}{local}{entities}
		\begin{call}{local}{build()}{entity}{Entity}
			\mess{entity}{gotten}{events}
		\end{call}
	\end{call}
	\begin{call}{store}{Resolve(entities)}{transaction}{}
		\mess{transaction}{gotten}{events}
		\mess{transaction}{resolve}{user}
	\end{call}
\end{call}

\end{sequencediagram}

When the remote transaction returns data, the store's underlying deferred will
resolve with the data. The local runtime will expand the data, before telling
the transaction the {\ilcode get} is complete. The userspace promise is then
resolved. \footnote{The RemoteRuntime isn't actually a thread- the first
{\ilcode resolve(data)} arrow should be a message, but the tool to generate the
diagram doesn't support that. :(}

\newpage
\section{Reference}

\subsection{Glossary}

\indent\glossary{Attribute}{An object on contexts, entities, and property
definitions, specifying optional information that a runtime can use to provide
enhanced functionality in a modular fashion.}

\glossary{Context}{A description of the entities in a JEFRi application.}

\glossary{Deferred}{An object that manages a callback chain.}

\glossary{Entity}{A discreet, addressable structure of data with properties and
well-defined relationships to other entities.}

\glossary{Object}{A key/value store, closer to the JSON definition of an object.
An entity in JEFRi is closer to the idea of an instance in classical
inheritance.}

\glossary{Persistence Store}{A persistence store is used by an application to
retrieve additional data, and to send persist transactions to ensure data is
stored outside the runtime's memory. A persistence store either can operate on
data in some local persistence mechanism (eg. a database or filesystem), or can
be a proxy to a remote JEFRi runtime, which itself may have a persistence store
operating on some local data storage.}

\glossary{Property}{A field of an entity that holds a piece of data.}

\glossary{Relationship}{A description of how two or more entities are related to
one-another.}

\glossary{Runtime}{An instance of the underlying application code which provides
the necessary code to instantiate, manage, and transact entities.}

\glossary{Transaction}{A serializable representation of a request to retrieve or
store data between a local and remote JEFRi runtime.}

\subsection{Sample Context}
\linespread{1}
\begin{lstlisting}
{"meta":{},
"entities":[
	{	"name": "User",
		"key": "user_id",
		"properties": [
			{	"name": "user_id",
				"type": "uuid"},
			{	"name": "name",
				"type": "string"},
			{	"name": "email",
				"type": "string",
				"attributes": {
					"unique": "true"}}
		],
		"relationships": [
			{	"name": "authinfo",
				"type": "has_a",
				"property": "user_id",
				"to": {
					"type": "Authinfo",
					"property": "user_id"}
			},

			{	"name": "cards",
				"type": "has_many",
				"property": "user_id",
				"to": {
					"type": "Card",
					"property": "user_id"}}
			]
	},

	{	"name": "Card",
		 "key": "card_id",
		 "properties": [
			{	"name": "card_id",
				"type": "uuid"},
			{	"name": "user_id",
				"type": "int"},
			{	"name": "name",
				"type": "string",
				"attributes": {
					"nullable": "true"}},
			{	"name": "email",
				"type": "string",
				"attributes": {
					"nullable": "true"}},
			{	"name": "phone",
				"type": "string",
				"attributes": {
					"length": 17,
					"nullable": "true"}},
			{	"name": "address",
				"type": "string",
				"attributes": {
					"nullable": "true"}},
			{	"name": "city",
				"type": "string",
				"attributes": {
					"nullable": "true"}},
			{	"name": "state",
				"type": "string",
				"attributes": {
					"nullable": "true",
					"length": "5"}},
			{	"name": "postal",
				"type": "string",
				"attributes": {
					"nullable": "true",
					"length": "10"}},
			{	"name": "country",
				"type": "string",
				"attributes": {
					"nullable": "true",
					"length": "2"}}],
		 "relationships": [
			{	"name": "user",
				"type": "has_a",
				"property": "user_id",
				"to": {
					"type": "User",
					"property": "user_id",
					"vname": "user"}}],
	},

	{	"name": "Authinfo",
		 "key": "authinfo_id",
		 "properties": [
			{	"name": "authinfo_id",
				"type": "int",
				"attributes": {
					"primary": "true"}},
			{	"name": "user_id",
				"type": "int",
				"attributes": {}},
			{	"name": "username",
				"type": "string",
				"attributes": {
					"length": "45"}},
			{	"name": "password",
				"type": "string",
				"attributes": {
					"length": "45"}}],
		 "relationships": [
			{	"name": "user",
				"type": "has_a",
				"property": "user_id",
				"to": {
					"type": "User",
					"property": "user_id"}}],
	}
]}
\end{lstlisting}

\subsection{Sample {\ilcode get}}
A {\ilcode get} transaction for all data on davidsouther@gmail.com in the US.
\linespread{1}
\begin{lstlisting}
{"entities": [
	{
		"_type": "Authinfo",
		"username": ["=", "davidsouther@gmail.com"],
		"user": {
			"cards": {
				"country": "US"
			}
		}
	}
]}
\end{lstlisting}
\subsubsection{Translated SQL}

\lstset{language=SQL}
\begin{lstlisting}
SELECT
	authinfo.user_id AS 'authinfo.user_id',
	authinfo.username AS 'authinfo.username',
	authinfo.password AS 'authinfo.password',
	user.user_id AS 'user.user_id',
	user.name AS 'user.name',
	user.email AS 'user.email',
	card.card_id AS 'card.card_id',
	card.user_id AS 'card.user_id',
	card.name AS 'card.name',
	card.email AS 'card.email',
	card.phone AS 'card.phone',
	card.street AS 'card.street',
	card.city AS 'card.city',
	card.state AS 'card.state',
	card.zip AS 'card.zip',
	card.country AS 'card.country'
FROM "authinfo"
	JOIN "user" ON (authinfo.user_id = user.user_id)
	JOIN "card" ON (user.user_id = card.user_id)
WHERE
	authinfo.username = 'davidsouther@gmail.com'
	AND
	card.country LIKE '%US%'
\end{lstlisting}

\end{document}
