\documentclass{article}

\usepackage{color}
\usepackage{hyperref}
\usepackage[underline=true,rounded corners=false]{pgf-umlsd}
\usepackage{listings}
\lstset{ %
	language=Java,                % the language of the code
	basicstyle=\footnotesize,       % the size of the fonts that are used for the code
	numbers=left,                   % where to put the line-numbers
	numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
	stepnumber=1,                   % the step between two line-numbers. If it's 1, each line
	                                % will be numbered
	numbersep=5pt,                  % how far the line-numbers are from the code
	backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
	showspaces=false,               % show spaces adding particular underscores
	showstringspaces=false,         % underline spaces within strings
	showtabs=false,                 % show tabs within strings adding particular underscores
	frame=single,                   % adds a frame around the code
	tabsize=4,                      % sets default tabsize to 2 spaces
	captionpos=b,                   % sets the caption-position to bottom
	%breaklines=true,                % sets automatic line breaking
	breakatwhitespace=false        % sets if automatic breaks should only happen at whitespace
}

\usepackage{fullpage}
\linespread{1.3}

\newcommand{\ilcode}{\tt}
\newcommand{\method}[4]{
	\noindent
	\begin{tabular}{ | l | p{5in} | }
	\hline
	\multicolumn{2}{|l|}{\large \ilcode #1 ({\it #2})} \\
	\hline
	\multicolumn{2}{|p{6in}|}{#3} \\
	\hline
	#4
	\end{tabular}
}
\newcommand{\param}[2]{
	{\ilcode #1} & #2 \\
	\hline
}
\newcommand{\event}[4]{\method{#1}{#2}{#3}{#4}}

\renewcommand{\glossary}[2]{{\large \textbf #1} #2 \\ }

\begin{document}

\title{JEFRi - JSON Entity Framework Runtime}
\maketitle
\tableofcontents
\newpage
\linespread{1.6}

\section{Overview}

JEFRi is an entity framework. Entity Frameworks allow developers to specify data
descriptions and relationships once for their application, then share data
throughout the application space in a unified way. JEFRi accomplishes this by
specifying an Entity Context independent of any programming language. This
context describes the entities available in the domain model, the properties of
those entities, and any additional attributes needed to make the model suitably
robust. Further, it describes the relationships between entities. These
navigation properties allow entities to act naturally and transparently as
composite types. This allows intelligent loading of related data, without
requiring an application to load an entire object graph.

An Entity Framework provides a wealth of functionality over a pure Object-
Relational Mapper. Straight ORMs simply translate between a database table and
an instantiated object. A full EF includes tracking modifications of entities,
descriptive methods to navigate entity relationships, intelligent sharing
between framework instances, and more. JEFRi is a specification for how to
define these entities, how to share these entities, and many other features
enabling software projects to quickly and efficiently work with their data.


\section{Entities}

Entities are independent, identifiable components of an application's model.
Entities are analogous to Objects in OOP, and Table Rows in databases. Entities
are the building blocks of the domain, the things the domain is modeling.
Entities could be receipts in a Point of Sale application, Clients in Contact
Management System, or Planets in a physics model. Entities within an entity
framework are endowed with a variety of backing infrastructure, including tools
to share data between runtimes, tools to store data to various persistence
layers, tools to track the history of the entity, and more.

\subsection{Keys}

Every Entity must have a key --- a single unique field identifying that entity
across all instances of any runtimes. To meet this requirement in a distributed,
heterogeneous environment, keys are recommended to be version 4 (random) UUIDs.
Keys are used exclusively to refer to entities of a specific type. To maintain
unique object graphs when flattening into transactions, the key is used as an
object identifier, saving the need to handle issues of using memory references
or incrementing integers as keys.

Entity keys are immutable --- once an entity has been instantiated, its key must
not change. Anything that would cause a change in they key must instead create
a new entity instance.

Keys should be generated by whichever runtime initially creates a new instance
of an entity. Thus, it is important that JEFRi instances provide suitably robust
random number generators. By having the key assigned by the runtime that first
creates an entity, applications eliminate the need for a central repository of
canonical key information. Without a central key store, applications can be free
to handle concurrency with whatever mechanism best fits the domain model.
Further, since applications don't need to synchronize keys, significant
reductions in bandwidth are seen. The concern of conflicting keys is mitigated
by choosing a sufficiently large key domain. Further, keys must only be unique
to entity types. Thus, randomly generating Version 4 UUIDs allows 6 million
billion keys per entity type before reaching a 50\% chance of a single collision
amongst keys.

We will see later that a type's full URN within a runtime is technically
{\ilcode entity://\-application/\-context/\-type/\-uuid}, so it is arguable that
UUIDs are ``Too Much". Then again, no one needs more than 640K. If a context
expects more entities of some type than this, it would be simple to replace the
key generator implementation with something more suitably robust for that
application.

\subsection{Properties}

Properties are the non-independent pieces of data that describe an entity. These
are the columns in a table, or the fields of an object. Properties of an entity
have a variable name, a type, and optional attributes. The name is the
identifier that will be used throughout the JEFRi runtimes. Allowed types are
{\ilcode int}, for a finite whole-number (possibly negative) value; {\ilcode
float}, for a decimal floating-point number with at least 32 bits of machine
precision; {\ilcode boolean}, for data that can have a value of {\ilcode true}
or {\ilcode false}; and {\ilcode string}, a list of zero or more character
values. Within a runtime, the types may be represented however makes most sense
for that platform. When transfering data between runtimes, property values
should be transmitted using JSON definitions for values.

\subsection{Relationships}

Relationships describe how entities interact with and reference other entities.
This allows developers to write very natural expressions when moving between
data records.

Relationships have two ends, the {\ilcode from} and and the {\ilcode to} end.
These ends change roles depending on which entity is accessing the relationship.
The {\ilcode from} end is always the side of the relationship doing the
accessing, and the {\ilcode to} end is the side being accessed. Ends have a
{\ilcode type} and a {\ilcode property}. The {\ilcode property} tells which
property holds the key for that end, and the {\ilcode type} property describes
how the {\ilcode to} end should be accessed. Ends have two types- {\ilcode
has\_a} and {\ilcode has\_many}. A third type, {\ilcode is\_a}, is a specialized
{\ilcode has\_a}.

When an application has an instantiated entity, relationships can be navigated
by calling the appropriate {\ilcode get\_`navprop'} method of the entity. For
example, if a Receipt has an associated Client, you could call {\ilcode
receipt.get\_client()} which would return a single Client. Conversely, from the
client end, you could call {\ilcode client.get\_receipts()} to return an array
of Receipt entities. Notice how the navigation methods are properly pluralized.
This is a result of naming the relationships {\ilcode user} and {\ilcode
receipts} in the context- it is not the runtime's responsibility to handle
pluralities, but the context generator's.

\subsection{Attributes}

Attributes provide meta-information about entities and properties. All entities
have a key attribute, that tells which property holds the entity's keys. All
properties have a type attribute, describing what data they hold. Beyond some
minimal required data, attributes can contain any additional information the
application may need. It is the responsibility of the application to use that
data --- the context will merely hold it.

\section{Contexts}

JEFRi Contexts are descriptions of the entity model. Contexts are described here
as JSON objects, though can be any persistable object serialization. Contexts
are objects with two properties --- {\ilcode meta}, describing the overall
context options, and {\tt entities}, an array of entity descriptions.

A context's {\ilcode meta} is an object containing arbitrary keyed data for a
runtime's consumption. For example, a {\ilcode meta} could declare {\ilcode
persistOnUpdate} to be true. In this case, the runtime could then automatically
attempt to persist an entity any time its properties were updated. The list of
canonical {\ilcode meta} attributes and their meaning will grow organically as
JEFRi is fleshed out. Otherwise, the documentation for a particular
implementation must specify the {\ilcode meta} attributes it handles, as well as
their meanings.

The {\ilcode entities} array is the heart of the context. Each entry describes
one entity type available. The entres are objects with five keys. Those are
{\ilcode name}, the canonical name for the entity type; {\ilcode key}, the
property containing the entity's UUID; {\ilcode properties}, an array containing
the properties of the entity; {\ilcode relationships}, an array containing
descriptions of the various navigation properties; and {\ilcode attributes}, an
object describing various metadata about the entity itself.

{\ilcode name} is the canonical type name for an entity. It is used extensively
to look up property definitions from several points in the application,
especially when creating new entities, persisting entities, and navigating
entity relationships. Entity names must be unique within a context. Entity names
must be valid Javascript object keys --- {\ilcode $=\sim$
/[a-zA-Z\_\$][a-zA-Z0-9\_\$]+/}

{\ilcode key} is the name of the property containing the entity's key. See the
section on entity keys for more details on how keys are used in JEFRi.

{\ilcode properties} is an array of objects similar in layout to entities, but
without keys or relationships. Specifically, properties must define a name, a
type, and an array of attributes. The name is the Javascript-safe property
identifier, and must be unique among the properties of an entity. The type is
the platform- agnostic datatype specifier. Canonically recognized types are
{\ilcode int}, {\ilcode float}, and {\ilcode string}.

{\ilcode attributes} is an object of arbitrary key/value pairs. Currently
recognized keys are {\ilcode nullable}, allowing the field to have an
appropriate value or {\ilcode null}; and {\ilcode length} for string, specifying
the maximum number of characters. Again, it is the runtime implementor's
responsibility to document recognized attributes and their behavior.

{\ilcode relationships} is an array describing the various navigation properties
available to an entity. A relationship has four keys --- {\ilcode name}, the
identifier for the navigation; {\ilcode type}, one of {\ilcode is\_a}, {\ilcode
has\_a}, or {\ilcode has\_many}; and {\ilcode to} and {\ilcode from}, describing
the entities taking part in the relationship. Name must be a locally unique,
valid Javascript identifier. Further, it defines which {\ilcode get\_} method
must be called to navigate the relationship (specifically, {\ilcode
entity.get\_`name'()}). {\ilcode type} determines what will be returned when
navigating the relationship. {\ilcode has\_a} and {\ilcode is\_a} will return a
single entity, while {\ilcode has\_many} will return a (possibly empty) array of
entities. There is some indication that the far side of a {\ilcode has\_a} or
{\ilcode has\_many} relationship will probably have a {\ilcode has\_a} or
{\ilcode has\_many} navigation that would lead back to the entity on the from
side (however, this is not a requirement). {\ilcode is\_a} will not have a
reverse navigation. JEFRi does not support the concept of casting down.

Finally, the {\ilcode from} and {\ilcode to} properties describe where to look
up the data needed for the navigation. In all relationships, both the {\ilcode
from} and {\ilcode to} type fields {\it must} resolve to a valid entity name in
the same context (TODO possibly change this so there is a possibility for cross-
context navigation?). The property fields are used slightly differently
depending on what the type of the relationship is. In a {\ilcode has\_a
relationship}, the {\ilcode to.property} should be the same as the {\ilcode
to.type.key}, and the navigation property will return the one {\ilcode to.type}
whose key is equal to the {\ilcode from.property}. The opposite is similar for
{\ilcode has\_many}.

\subsection{Runtimes}

Instances of JEFRi contexts need some mechanism for long-term persistence of
entity data. Persistence stores provide this by providing a flexible, driver-
based approach. Persistence stores must provide a persist and a get method, each
taking a JEFRi transaction (see next section) and performing the appropriate
actions. Stores should also provide an {\ilcode is\_async} method, which tells
the user whether to expect the store to return immediately, or happen in the
background with a callback.

The persist method must function atomically per transaction. It is the
responsibility of the persistence store to ensure that transactions happen
atomically. In general, it is the persistence store's responsibility to meet the
semantics specified in the section on Transactions.

The get method must handle the myriad of filter and join operations available in
the transaction specifications. See the section on transaction specifications
for the exact semantics of get requests.

\subsection{Persistence Stores}
Persistence stores

\section{Transactions}

The most important, fundamental concept in computer programing is the word-level
atomic write. Since the first computers, it was impossible to read an
inconsistent word of memory- if a read and a write occur {\sl simultaneously},
the read will either return the value in memory BEFORE the write, or the value
in memory AFTER the write. It will NEVER return some of the before and some of
the after bits. At a hardware level, this only works with the smallest
addressable batch of memory --- a word. Since entities are probably always going
to be bigger than a single word (integer UUIDs alone are 2 full words on a
64-bit machine), it is not possible to achieve atomic entity persistence in
hardware alone. Still, it is necessary to have guaranteed atomic writes for
entity data.

JEFRi transactions fill this gap. When a runtime is ready to persist a batch
of entity updates, it builds a serializable object representation of just the
pieces that need to be updated. By using entity keys extensively, the runtime
can flatten the object graph into an object list, with guaranteed unique
references between the entities. This transaction detail can then be sent
between runtime instances, with some guarantee that that information is
consistent (generally, that guarantee will come from TCP).

JEFRi has two transaction types: {\ilcode get} and {\ilcode persist}. A {\ilcode
get} transaction is used to request data from a remote JEFRi instance. A
{\ilcode persist} transaction is used to update data at a remote JEFRi instance.
Transactions are a serialized object with two properties: {\ilcode meta}
describing the transaction, and {\ilcode entities}, describing the entities to
deal with.

In a {\ilcode get} transaction, the entities array is a template for which
entities should be returned. The return transaction will contain all entities
that meet the criteria specified in the transaction. Specifically, the remote
instance will look at the first object in the transaction. It will return all
entities of that type whose properties match the given properties. It will join
specified navigation properties (using just {\ilcode name}, not {\ilcode
get\_name}). It will do this for each entity in the array. In other words, the
individual entities specify AND conditions, while the multiple entities specify
OR conditions.

In a {\ilcode persist} transaction, the entities array has the literal data that
must be persisted. The remote JEFRi runtime is responsible for making the
persist atomic and returning a transaction filling in the additional or updated
details it has about these entities that was not included in the original
transaction (eg, a JEFRi instance may persist an entity to a runtime using DB2
as a backend, where one property has an update trigger setting the timestamp to
`now' --- the reply transaction would include the updated value for that
property).

\subsection{Transaction Specifications}

Data for a transaction should be described as close to the domain model as
possible. However, requiring only full entities would result in more verbose
transactions than necessary. To that end, the specification to a transaction
will be an array of objects describing the entities in the transaction. The
format should be similar to:

\linespread{1}
\begin{lstlisting}
[{
	type: `User',
	surname: `Franken',
	prop2: value2,
	cards: {}
}]
\end{lstlisting}
\linespread{1.6}

If this were a {\ilcode get} transaction, the reply would have an array of
entities of {\ilcode User} and {\ilcode Card}, with all the {\ilcode User}
entities having {\ilcode surname = `Franken', prop2 = value2}, and all the
{\ilcode Card}s correctly associated with the matched Users.  Navigation
property objects can specify constraints on the nav properties returned, and can
themselves declare navigation properties to return. It is not necessary to
specify a type in a navigation property --- any that are will be ignored.

If this were a {\ilcode persist} transaction, the {\ilcode key} property {\it
must} be included. The persistent store would update (or store) the values of
the entity with the properties passed in. To save navigation properties, each
entity that is part of the navigation should be added individually.

\subsubsection{Gory Get Details}

To capture the full expressivity developers need in describing data, there are
several rules transactions will use to determine the entities to return from a
{\ilcode get} transaction.

If the property is the entity key, it will be converted to an appropriate format
for the store, and the property must match exactly. While the UUID can be
transmitted as a hex string, it is recommended to transmit it as a 16-byte
integer to conserve space, when possible.

If value is an integer, properties must match exactly.

If value is a float, either it should be matched at a $2^{-8}$ threshold or it
can be the first number of an array tuple, whose second parameter specifies the
threshold precision as an integer $n$ such that the threshold is $2^{-n}$.

If the value is a string, it will be treated as an SQL LIKE operation. Returned
entities will have properties whose values contain the string (case sensitive).

If the value is an array, the first field in the array may specify an operation,
may be a floating point number (see above), may be a compound filter, or may be
an enumeration of values the filed's value must be {\ilcode in}.

Valid operations are any of {\ilcode $<$}, {\ilcode $<=$}, {\ilcode $>$},
{\ilcode $>=$}, {\ilcode $=$}, and {\ilcode REGEX}. {\ilcode REGEX} treats the
next value as a PCRE regular expression, and any returned entities will have
that property matching the regex. Otherwise, the operations are as specified by
the store, but generally should be numerical ordering for numbers, and
lexicographical ordering for strings.

%SUM? AVERAGE? COUNT? MAX? MIN?

%GROUP BY?

If the value is an array whose first parameter is not an operator or another
array, the returned entity's property will match as an IN clause, with integers
matching exactly and string matching as described above.

If the first parameter is an array, then each element of the value's array is
treated as an ANDed where clause, with the components of sub arrays following
the same (value) or (operator, value) rules presented here.

Using a common SQL driver,
\linespread{1}
\begin{lstlisting}
[{
	_type: `User',
	surname: `Franken',
	date_of_birth: [
		[`<=', 1200000000],
		[`>=', 1100000000]
	],
	cards: {}
}]
\end{lstlisting}
\linespread{1.6}

becomes

\linespread{1}
\begin{lstlisting}
SELECT
	User.user_id AS user.user_id,
	User.surname AS user.surname,
	User.given_name AS user.given_name,
	User.login AS user.login,
	User.date_of_birth AS user.date_of_birth,
	Card.card_id AS card.card_id,
	Card.user_id AS card.user_id,
	Card.name AS card.name,
	Card.email AS card.email,
	Card.phone AS card.phone,
	Card.address AS card.address,
	Card.city AS card.city,
	Card.state AS card.state,
	Card.postal AS card.postal,
	Card.country AS car.country,
FROM USER
LEFT JOIN Card on User.user_id = Card.card_id
WHERE
	User.surname LIKE `%Franken%'
	AND User.date_of_birth <= 1200000000
	AND User.date_of_birth >= 1100000000
\end{lstlisting}
\linespread{1.6}

Since this is a left join and there are no constraints on {\ilcode Card}, this
query will return a number of rows equal to the total number of matched cards.
With more than one contact card per {\ilcode User}, some of the User data will
be duplicated. The runtime the store is running in will intern all the instances
of the different {\ilcode Users}, so there will be no duplicated entity
instances in memory.

\subsection{Best Persist Practices}

Persist transactions are an application's way to send changed entities to
another runtime. For a database-backed entity store, these transactions could
return quickly. For a store that has to post the transaction to a remote host,
the persist might take much longer. To unify the interface, all transactions are
asynchronous, and return a deferred promise\footnote{For a full explanation of
deferreds and their promises, see the \hyperref[jQuery documentation]
{http://api.jquery.com/category/deferred-object} --- jQuery has the most
complete and robust deferred implementations today}. With this in mind, there
are three separate techniques or approaches to handling a persist transaction.

The first approach is managing the transaction directly. The application readies
a transaction by calling {\ilcode ec.transaction()}. The application can then
add a number of entities to the transaction via {\ilcode
transaction.add(entity)}. Finally, the application should call {\ilcode
transaction.persist()} to persist and finalize the request. The same entity can
be added multiple times without being duplicated in the final send.

The second is persisting the changes to a single entity. Every entity has a
function {\ilcode persist()}. This function will generate several events,
including {\ilcode entity.on\_persist(transaction)}, passing in the transaction
that will handle the persist request. The entity should use this to add related
data to the transaction. This technique can be combined effectively with the
first approach.

The final technique is a pair of helper methods in the EntityContext itself. The
EC maintains an internal record of what entities have been changed, and what
entities have been added. The two methods {\ilcode ec.persist\_new(callback)}
and {\ilcode ec.persist\_changes(callback)} can be used to easily persist all
entities that have been modified, but not persisted.

\subsection{Entity Accounting}

To facilitate minimizing data transfer, entities and the EntityContext keep
track of changes that occur during runtime. The EntityContext maintains an array
of new entities and an array of modified entities. These can be used to quickly
index what needs to be sent in {\ilcode persist\_changes} or {\ilcode
persist\_new}.

Entities maintain accounting information regarding their status. This is stored
in two properties and a function.

{\ilcode \_\_new} Boolean property, set to true if this is a new entity.

{\ilcode \_\_modified} Object whose keys are property names that have been
updated, and those values are the value when the object was last persisted (or
the default value, if the entity is new). When an property of an entity is set,
the entity should check in its {\ilcode \_\_modified} object for the property.
If the property is not in \_\_modified, set {\ilcode \_\_modified[property]} to
the current value of {\ilcode entity[property]}, update {\ilcode
entity[property]}, and add itself to the EntityContext's {\ilcode \_modified}
list. If the property {\it  is} in {\ilcode \_\_modified}, and the value in
{\ilcode \_\_modified} is the same as the setter's value, then the entity should
set its property and remove the property from \_\_modified. If that was the last
property in \_\_modified, the entity should remove itself from the
EntityContext's modified list.

{\ilcode \_status()} Is a function returning one of {\ilcode NEW}, {\ilcode
MODIFIED}, or {\ilcode PERSISTED}. An entity is in the {\ilcode NEW} state if it
has been created, but never taken part in a {\ilcode persist} transaction. An
entitiy is {\ilcode MODIFIED} if it has been successfully persisted in the past,
but has had a property modified and not reset since the last persist. An entity
is {\ilcode PERSISTED} if it has been part of a successful persist transaction,
and has not had any of its property values updated, or all its property have
been set to their last persisted values.

Every entity has a default {\ilcode persisted} event handler that clears the
modified object, clears the new flag, and removes the entity from the
EntityContext's new and modified arrays.

\section{API}

Context Methods are called on an instance of a JEFRi runtime, and include many
data access routines. Entity methods are called on instances of entities, and
include primarily navigation properties, as well as entity-specific persistence
methods. Transaction methods are called on a class which manages large {\ilcode
get} and {\ilcode persist} transactions. Data Store methods mirror Transaction
methods, but are generally only called from the transaction. However, there is
no formal `user-mode' constraints, so that is a recommendation, not a
requirement.

\subsection{Runtime Methods}
These are methods available for an active JEFRi Runtime.
\\
\\
\method{EntityContext}{URI, options, protos}
{The context CTOR. Creates a new context from the json at the URI given,
	and extends the entity classes with the protos.}
	{
		\param{URI}{The URI for the context description.}
		\param{options}{An object containing override parameters.}
		\param{protos}{An object whose keys are Entity types, and whose values
			are the new prototypes for that entity.}
	}

\method{definition}{type}
	{Returns the context's definition for the specified type.}
	{}

\method{extend}{type, proto}
	{Add the methods in proto to type's prototype. Will effect {\it ALL}
	instances, both current and future, of {\ilcode type}.}{}

\method{build}{type, obj}
	{Return an non-interned instance of {\ilcode type} with properties
	filled in from {\ilcode obj}.}{}

\method{intern}{entity, updateOnIntern}
	{Returns a canonical instance of the {\ilcode entity} from memory. Use this
	to translate between UUIDs and pointers (or similar machine references). If
	the boolean {\ilcode updateOnIntern} is true, and there is a previously
	stored {\ilcode entity}, the old {\ilcode entity} will be updated with any
	non-default properties of the new entity.}{}

\method{expand}{transaction}
	{Expand the results of a {\ilcode transaction} into the runtime. Intern
	where possible, and call {\ilcode add\_`name'} and {\ilcode set\_`name'
	where} appropriate.}{}

\subsection{Entity Methods}
These are the defined JEFRi methods on an instantiated entity.
\\
\\
\method{id}{}
	{Return the UUID of the object, independent of whichever property
			actually stores it.}{}

\method{\_type}{}
	{Returns a string of the canonical entity type.}{}

\method{get\_`name'}{}
	{Follow a navigation property. Returns either a single or (possibly
			empty) array with the to end of the relationship.}{}

\method{set\_`name'}{to\_entity}
	{Set the {\ilcode has\_a} navigation property. Correctly updates
			each entities' navigation property values.}{}

\method{add\_`name'}{to\_entity}
	{Add to the {\ilcode has\_many} array.}{}

\method{encode}{writer}
	{Pass the {\ilcode entity}, its properties, and its navigation properties to
		the	transaction writer.}
	{}

\subsection{Transaction Methods}
Transactions allow for communication between JEFRi runtimes. These are the
methods available to create and manipulate transactions.
\\
\\
\method{Transaction}{entities}
	{Constructor. Entities describes the data in the transaction. See the
			section on Transactions for details.}{}

\method{add}{entities}
	{Add these entities to the transaction.}{}

\method{meta}{attributes}
	{Specify {\ilcode meta} attributes. Any attribute can be added. The remote
	runtime is responsible for specifying how it handles these attributes.}{}

\method{get}{}
	{Run the transaction as a get transaction.}{}

\method{persist}{}
	{Run the transaction as a persist transaction.}{}

\subsection{Events}
Throughout the lifetime of a JEFRi runtime, a variety of events are triggered
allowing application code to handle and modifying JEFRi actions in a variety of
ways.

\subsubsection{EntityContext}
\event{saving}{}
	{Triggered when an EntityContext begins to save data.}
	{}

\event{saved}{}
	{Triggered when an EntityContext has finished persisting data to a remote
	runtime.}
	{}

\subsubsection{Entity}
\event{persisting}{this}
	{Triggered during the transaction lifecycle when a transaction begins to
	persist to a remote runtime, but before the data has been sent.}
	{\param{this}{A reference to the entity itself.}}

\event{persisted}{this}
	{Triggered during the transaction lifecycle, after it has been confirmed
	that the entity was persisted in the remote runtime.}
	{\param{this}{A reference to the entity itself, with updated field values
	from the persist transaction.}}

\event{gotten}{this}
	{Triggered after an entity has been returned and interned from a {\ilcode
	get} transaction}
	{\param{this}{A reference to the entity, with properties updated from the
	values returned in the transaction.}}

\subsubsection{Transaction}
\event{getting}{this}
	{Triggered when a {\ilcode get} transaction is ready to be sent to a remote
	runtime, but before it has been passed to the store.}
	{\param{this}{A reference to the transaction.}}

\event{gotten}{this}
	{Triggered when a {\ilcode get} transaction has been completely expanded.}
	{\param{this}{A reference to the transaction.}}

\event{persisting}{this}
	{Triggered when a {\ilcode persist} transaction is ready to be sent to a
	remote runtime, but before it has been passed to the store.}
	{\param{this}{A reference to the transaction.}}

\event{persisted}{this}
	{Triggered when a {\ilcode persist} transaction has been completely
	expanded.}
	{\param{this}{A reference to the transaction.}}

\subsubsection{PersistStore}
\event{sending}{type, to\_url, transaction, this}
	{Triggered when a store is about to send a transaction to a remote runtime.}
	{
		\param{type}{Either `{\ilcode get}' or `{\ilcode persist}', depending on
			the type of the transaction.}
		\param{to\_url}{URL of the remote runtime the transaction is destined
			for.}
		\param{transaction}{A reference to the actual transaction.}
		\param{this}{A reference to the store sending the transaction.}
	}

\event{sent}{type, to\_url, transaction, promise, this}
	{Triggered after the request has been sent, but before it has returned with
		any data.}
	{
		\param{type}{Either `{\ilcode get}' or `{\ilcode persist}', depending on
			the type of the transaction.}
		\param{to\_url}{URL of the remote runtime the transaction is destined
			for.}
		\param{transaction}{A reference to the actual transaction.}
		\param{promise}{A reference to the {\ilcode promise} that will resolve
			when the transaction completes.}
		\param{this}{A reference to the store sending the transaction.}
	}

\subsubsection{Lifecycle}
This is the order of events fired during a PersistStore {\ilcode get} request.
There are two phases to the request, and are split between preparing the request
and getting a deferred promise for when the request returns, and when the
asynchronous request has actually completed.
\\
\\
\begin{sequencediagram}
\newthread{user}{User}
\newinst{transaction}{Transaction}
\newinst{store}{Store}
\newinst{remote}{Remote Runtime}
\newinst{events}{Event Handler}

\begin{call}{user}{get()}{transaction}{Promise}
	\mess{transaction}{getting}{events}
	\begin{call}{transaction}{`do'()}{store}{Promise}
		\mess{store}{sending}{events}
		\begin{call}{store}{$<<$ajax$>>$}{remote}{Promise}
		\end{call}
		\mess{store}{sent}{events}
	\end{call}
\end{call}

\end{sequencediagram}

The {\ilcode transaction} has been prepared before hand, and the user's code
calls {\ilcode transaction.get()} to begin the request. {\ilcode get()} will
return a deferred, which will resolve after the request has completed and been
completely expanded in the local runtime.
\\
\\
\begin{sequencediagram}

\newthread{remote}{Remote Runtime}
\newinst{store}{Store}
\newinst{local}{Local Runtime}
\newinst{entity}{[Entity]}
\newinst{transaction}{Transaction}
\newinst{events}{Event Handler}
\newinst{user}{User}

\begin{call}{remote}{resolve(data)}{store}{}
	\begin{call}{store}{expand(data)}{local}{entities}
		\begin{call}{local}{build()}{entity}{Entity}
			\mess{entity}{gotten}{events}
		\end{call}
	\end{call}
	\begin{call}{store}{Resolve(entities)}{transaction}{}
		\mess{transaction}{gotten}{events}
		\mess{transaction}{resolve}{user}
	\end{call}
\end{call}

\end{sequencediagram}

When the remote transaction returns data, the store's underlying deferred will
resolve with the data. The local runtime will expand the data, before telling
the transaction the {\ilcode get} is complete. The userspace promise is then
resolved. \footnote{The RemoteRuntime isn't actually a thread- the first
{\ilcode resolve(data)} arrow should be a message, but the tool to generate the
diagram doesn't support that. :(}

\newpage
\section{Reference}

\subsection{Glossary}


\glossary{Attribute}{An object on entities and property property definitions in
a context, specifying optional information that a runtime can use to provide
enhanced functionality in a modular fashion.}

\glossary{Context}{A description of the entities in a JEFRi application.}

\glossary{Deferred}{An object that manages a callback chain.}

\glossary{Entity}{A discreet, addressable structure of data with properties and
well-defined relationships to to other entities.}

\glossary{Object}{A key/value store, closer to the JSON definition of an object.
An entity in JEFRi is closer to the idea of an instance in classical
inheritance.}

\glossary{Persistence Store}{A persistence store is a remote JEFRi runtime used
by an application to retrieve additional data, and to send persist transactions
to ensure data is stored in other places.}

\glossary{Property}{A field of an entity that holds a piece of data.}

\glossary{Relationship}{A description of how two or more entities are related to
one-another.}

\glossary{Runtime}{An instance of the underlying application code which provides
the necessary code to instantiate, manage, and transact entities.}

\glossary{Transaction}{A serializable representation of a request to retrieve or
store data between a local and remote JEFRi runtime.}

\subsection{Sample Context}
\linespread{1}
\begin{lstlisting}
{"meta":{},
"entities":[
	{	"name": "User",
		 "key": "user_id",
		 "properties": [
			{	"name": "user_id",
				"type": "int",
				"attributes": {
					"primary": "true"}},
			{	"name": "surname",
				"type": "string",
				"attributes": {
					"length": "45"}},
			{	"name": "given_name",
				"type": "string",
				"attributes": {
					"nullable": "true"}},
			{	"name": "login",
				"type": "string",
				"attributes": {
					"length": "255",
					"unique": "true"}},
			{	"name": "date_of_birth",
				"type": "float",
				"attributes": {
					"nullable": "true"}}],
		 "relationships": [
			{	"name": "cards",
				"type": "has_many",
				"to": {
					"type": "Card",
					"property": "user_id",
					"vname": "user"},
				"from": {
					"type": "User",
					"property": "user_id",
					"vname": "user"}},
			{	"name": "authinfo",
				"type": "has_a",
				"to": {
					"type": "Authinfo",
					"property": "user_id",
					"vname": "user"},
				"from": {
					"type": "User",
					"property": "user_id",
					"vname": "user"}}]
		 "methods": [],
		 "attributes": {}},

	{	"name": "Manager",
		 "key": "user_id",
		 "properties": [
			{	"name": "user_id",
				"type": "int",
				"attributes": {
					"primary": "true"}}],
		 "relationships": [
			{	"name": "user",
				"type": "is_a",
				"to": {
					"type": "User",
					"property": "user_id",
					"vname": "user"},
				"from": {
					"type": "Manager",
					"property": "user_id",
					"vname": "user"}}}],
		 "methods": [],
		 "attributes": {}},

	{	"name": "Executive",
		 "key": "user_id",
		 "properties": [
			{	"name": "user_id",
				"type": "int",
				"attributes": {
					"primary": "true"}}],
		 "relationships": [
			{	"name": "user",
				"type": "is_a",
				"to": {
					"type": "User",
					"property": "user_id",
					"vname": "user"},
				"from": {
					"type": "Executive",
					"property": "user_id",
					"vname": "user"}}],
		 "methods": [],
		 "attributes": {}},

	{	"name": "Card",
		 "key": "card_id",
		 "properties": [
			{	"name": "card_id",
				"type": "int",
				"attributes": {
					"primary": "true"}},
			{	"name": "user_id",
				"type": "int",
				"attributes": {}},
			{	"name": "name",
				"type": "string",
				"attributes": {
					"nullable": "true"}},
			{	"name": "email",
				"type": "string",
				"attributes": {
					"nullable": "true"}},
			{	"name": "phone",
				"type": "string",
				"attributes": {
					"nullable": "true"}},
			{	"name": "address",
				"type": "string",
				"attributes": {
					"nullable": "true"}},
			{	"name": "city",
				"type": "string",
				"attributes": {
					"nullable": "true"}},
			{	"name": "state",
				"type": "string",
				"attributes": {
					"nullable": "true",
					"length": "5"}},
			{	"name": "postal",
				"type": "string",
				"attributes": {
					"nullable": "true",
					"length": "10"}},
			{	"name": "country",
				"type": "string",
				"attributes": {
					"nullable": "true",
					"length": "2"}}],
		 "relationships": [
			{	"name": "user",
				"type": "has_a",
				"to": {
					"type": "User",
					"property": "user_id",
					"vname": "user"},
				"from": {
					"type": "Card",
					"property": "user_id",
					"vname": "user"}}],
		 "methods": [],
		 "attributes": {}},

	{	"name": "Authinfo",
		 "key": "authinfo_id",
		 "properties": [
			{	"name": "authinfo_id",
				"type": "int",
				"attributes": {
					"primary": "true"}},
			{	"name": "user_id",
				"type": "int",
				"attributes": {}},
			{	"name": "username",
				"type": "string",
				"attributes": {
					"length": "45"}},
			{	"name": "password",
				"type": "string",
				"attributes": {
					"length": "45"}},
			{	"name": "activated",
				"type": "string",
				"attributes": {
					"nullable": "true",
					"length": "45"}},
			{	"name": "banned",
				"type": "string",
				"attributes": {
					"nullable": "true",
					"length": "45"}}],
		 "relationships": [
			{	"name": "user",
				"type": "has_a",
				"to": {
					"type": "User",
					"property": "user_id",
					"vname": "user"},
				"from": {
					"type": "Authinfo",
					"property": "user_id",
					"vname": "user"}}],
		 "methods": [],
		 "attributes": {}},
]}
\end{lstlisting}

\subsubsection{Sample Prototypes}
\begin{lstlisting}
{

}
\end{lstlisting}

\subsection{Sample {\ilcode get}}
\linespread{1}
\begin{lstlisting}
{
	_type: "Datapoint",
	datatype: {
		campaign: {
			campaign_id: "aac068f1-4fea-4922-8a32-7d8cf8f2923a"
		},
		options: "[boolean]",
	},
	product: {
		brand: {}
	},
	task: {
		location: {
			country: "AU"
		}
	}
}
\end{lstlisting}
\subsubsection{Translated SQL}
\begin{lstlisting}
SELECT
	datapoints.datapoint_id AS 'datapoints.datapoint_id',
	datapoints.task_id AS 'datapoints.task_id',
	datapoints.datatype_id AS 'datapoints.datatype_id',
	datapoints.value AS 'datapoints.value',
	datapoints.product_id AS 'datapoints.product_id',
	tasks.task_id AS 'tasks.task_id',
	tasks.parent_id AS 'tasks.parent_id',
	tasks.user_id AS 'tasks.user_id',
	tasks.campaign_id AS 'tasks.campaign_id',
	tasks.location_id AS 'tasks.location_id',
	tasks.title AS 'tasks.title',
	tasks.description AS 'tasks.description',
	tasks.earliest_start AS 'tasks.earliest_start',
	tasks.deadline AS 'tasks.deadline',
	tasks.estimate AS 'tasks.estimate',
	locations.location_id AS 'locations.location_id',
	locations.latitude AS 'locations.latitude',
	locations.longitude AS 'locations.longitude',
	locations.name AS 'locations.name',
	locations.address AS 'locations.address',
	locations.city AS 'locations.city',
	locations.state AS 'locations.state',
	locations.postal AS 'locations.postal',
	locations.phone AS 'locations.phone',
	datatypes.datatype_id AS 'datatypes.datatype_id',
	datatypes.campaign_id AS 'datatypes.campaign_id',
	datatypes.name AS 'datatypes.name',
	datatypes.description AS 'datatypes.description',
	datatypes.options AS 'datatypes.options',
	campaigns.campaign_id AS 'campaigns.campaign_id',
	campaigns.client_id AS 'campaigns.client_id',
	campaigns.name AS 'campaigns.name',
	campaigns.description AS 'campaigns.description',
	products.product_id AS 'products.product_id',
	products.brand_id AS 'products.brand_id',
	products.name AS 'products.name',
	products.description AS 'products.description',
	products.size AS 'products.size',
	brands.brand_id AS 'brands.brand_id',
	brands.client_id AS 'brands.client_id',
	brands.name AS 'brands.name',
	brands.description AS 'brands.description'
FROM "datapoints"
	JOIN "tasks" ON (datapoints.task_id = tasks.task_id)
	JOIN "locations" ON (tasks.location_id = locations.location_id)
	JOIN "datatypes" ON (datapoints.datatype_id = datatypes.datatype_id)
	JOIN "campaigns" ON (datatypes.campaign_id = campaigns.campaign_id)
	JOIN "products" ON (datapoints.product_id = products.product_id)
	JOIN "brands" ON (products.brand_id = brands.brand_id)
WHERE
	campaigns.campaign_id LIKE 'aac068f1-4fea-4922-8a32-7d8cf8f2923a'
	AND
	datatypes.options LIKE '%[boolean]%'
\end{lstlisting}

\end{document}
