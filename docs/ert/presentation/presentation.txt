Entities, Advisors, Templates

The Model-View-Controller architecture for GUI applications has shown its versatility time and again since its first use in the smalltalk environment. The proliferation of MVC frameworks speaks to this power, and the variations of Model-View-ViewModel and Model-View-Presenter show the flexibility of the fundamental approach. Even with the tremendous success of M-V-Star frameworks and approaches, there are unexplored techniques in the ecosystem.

Here, we will explore what can happen, and what support frameworks can provide, when we make several constraints on the Model is allowed to be. In this exploration, we will create an effective distributed data handling platform, a templating and scaffolding system that provides significant clarity over contemporary alternatives, and an innovative eventing library which offers an expanded vocabulary when considering the observer pattern.

The ideas are built out using JEFRi, an Entity Framework platform. The code samples will be in Coffeescript with some small additions when we speak about advisors, but the ideas, framework specification, and framework API could be implemented in any language.

Entities

The foundation of this focused approach to MVC is in an entity. An entity is an object built from a specific, shareable definition of the properties and relationships of the data an application is modeling. An entity framework, like JEFRi, is a framework built specifically around this concept of an application's data storage.

An application using an entity framework starts by building a Entity Relationship Diagram. While many application lifecycles will have some documentation of the entity model at some point, possibly driving database design around an ERD, JEFRi applications use the description of the entity model at its core.

Let's look at a context definition.

{"entities":{
	"User": {
		"key": "user_id",
		"properties": {
			"user_id": {
				"type": "string"},
			"name": {
				"type": "string"},
			"address": {
				"type": "string"}},
		"relationships": {
			"authinfo": {
				"type": "has_a",
				"property": "user_id",
				"to": {
					"type": "Authinfo",
					"property": "user_id"}}}},

	"Authinfo": {
		"key": "authinfo_id",
		"properties": {
			"authinfo_id": {
				"type": "string"},
			"user_id": {
				"type": "string"},
			"username": {
				"type": "string"},
			"password": {
				"type": "string"}},
		"relationships": {
			"user": {
				"type": "has_a",
				"property": "user_id",
				"to": {
					"type": "User",
					"property": "user_id"}}}}}}

Here represented as a JSON object, let's walk through this basic user authentication system. The entity context starts here with a single property, "entities". Each key in this object is the name of an entity type our application will have available, and the value is the definition.

Our two entities are "User" holding the basic, commonly-accessed user information that will be needed often in our application. The other entity is the "Authinfo", which has details specifically concerning checking the user's login credentials.

Each entity has a couple properties. In this example, everything is a string, but more types are available to frameworks.

There are also relationships here. Each user has a single authinfo, and each authinfo is attached to a particular user. The relationship definitions provide a few details, including how the relationship will be accessed in the application code, and how related entities will be found at runtime.

Let's look at some code that uses this context.

	runtime = new JEFRi.Runtime("testContext.json")
	runtime.ready.done ->
		user = runtime.build "User", {name: "southerd", address: "davidsouther@gmail.com"}

		ok user.id().match(/[a-f0-9\-]{36}/i), "User should have a valid id."
		equal user.id(), user.user_id(), "User id() and user_id properties must match."
		equal user.name("David Souther").name(), "David Souther"
		equal user._status(), "NEW", "Built user should be New"

		authinfo = user.authinfo(runtime.build('Authinfo', {})).authinfo()
		equal authinfo.user_id(), user.id(), "Authinfo refers to correct user."

		user2 = runtime.build "User", {name: "portaj", address: "rurd4me@example.com"}
		authinfo2 = user2.authinfo();

		ok authinfo2, "Default relationship created."
		ok authinfo2.id().match(/[a-f0-9\-]{36}/i), "Authinfo2 should have a valid id."
		equal authinfo2.user_id(), user2.id(), "Authinfo2 refers to correct user."
		equal authinfo2.user().id(), user2.id(), "Authinfo2 returns correct user."

This code is pulled from some of JEFRi's unit tests.

It starts by loading the context into a new runtime. This will be the main access point for all our data management, including entity creation and data storage.

Loading the context is an asynchronous task, so here we hook into a deferred chain.

When the context is ready, we build our first User. Once we have a user, we can look at what's provided by the Runtime.

First, we have a call to the ID accessor. This is a default method provided by the runtime, so entities can store their identifying data anywhere needed, and applications can find their address without needing to look at the definition first.

Next, we have the user_id accessor. The runtime here provides an overloaded getter/setter pattern; if no value is provided, it returns the current value. Otherwise, it updates the entity, and returns a reference to the entity.

There are a few provided utility methods available on entities. To avoid naming collisions, they are prefixed with an underscore, except for id. _status specifically returns an enumeration stating the data persistence state, describing if the entity has been persisted to some other JEFRi runtime.

Relationships behave exactly like properties, except using entity references instead of primitive values. Notice in the second part of the example, the runtime can create a default instance of an entity if the relationship is called, but no entity is loaded.

### Parallels to...

#### ORM

Entities with relationships and properties are very similar to current active record patterns. Instances of entities generally map to a row in a database table, with columns holding property values. The increased power comes in the single, well-defined entity context. With that context describing the data, the relational database becomes just another projection of the entity data.

#### Document Storage

In flight, entity data is usually represented as a JSON string. While it is then expanded to an in-memory instance when received by a runtime, viewing entities as documents in a document storage system is a very apt view. The power again comes from having a single defined entity context. With that context, Entities become type-definitions on top of document storage. Frameworks can make very smart decisions about the data they store.


I mentioned runtimes handle persistence. In this example, we see JEFRi using an HTML5 LocalStore utility to save the new data in the user's browser. By changing the store the runtime uses, we can get local SQL storage, remote REST storage, or a myriad other possibilities.

	runtime = new JEFRi.Runtime("testContext.json", {store: JEFRi.LocalStore}
	runtime.ready ->
		user = runtime.build("User", {name: "southerd", address: "davidsouther@gmail.com"});
		authinfo = user.authinfo();
		runtime.save_new().then (transaction) ->
			ok transaction.entities && transaction.attributes, "Transaction entities and attributes."
			ok transaction.entities.length == 2, "Transaction should only have 2 entities."
			stored = JSON.parse localStorage.getItem("User")
			ok stored[user.id()], "User's ID in stored User list."

Let's take a look at what we've got here.

With entities, we are trading the unconstrained possibilities of a loose data model for the more precise entity relationship definition. In practice, many applications already use a data model that fits these constraints. The increased expressivity of using a runtime built around such a definition provides a powerful tool for developers using this data.

Further, because the runtime knows so much about the data, it can provide an incredible amount of plumbing that other frameworks require the application developer to write. This includes data validation, data persistence, and distributed method calls, all in a neatly packaged yet interoperable system.

For more details, the full JEFRi runtime documentation is available at docs.jefri.org

We can now use this concept of entities to build a templating system that makes a number of assumptions about the data model, providing a wealth of opportunities to build a robust underlying framework.

This templating engine is called DataStamp, and clones pieces of a DOM template based on the data it's rendering. It works on the assumption that our application has entities, each with properties and relationships, and will render appropriately.

<!-- Framework -->
<div id="JEFRi">
	<div id="_default_theme">
		<div id="_default_entity">
			<div id="_default_property">
				<li id="view">
					<b data-stamp-text="_name" />
					<span data-stamp-text="_value" />
				</li>
				<span id="list">prop_list</span>
				<li id="edit">
					<b data-stamp-text="_name" />
					<input type="text" data-stamp-placeholder="_name" data-stamp-value="_value" />
				</li>
			</div>
			<div id="_views">
				<div id="view">
					<ul class="properties" />
					<div class="relationships">
						<h2>Relationships</h2>
					</div>
				</div>
			</div>
		</div>

	</div>
</div>

<!-- Application -->
<div id="JEFRi">
	<div id="_default_theme">
		<div id="User">
			<div id="user_id">
				<li id="view"><em>User ID:</em> <span data-stamp-text="_value" /></li>
				<li id="edit"><em>User ID:</em> <span data-stamp-text="_value" /> <span class="invalid">You can't edit the ID.</span></li>
			</div>
		</div>
		<div id="Authinfo">
			<div id="banned">
				<li id="edit"><b>Banned:</b> <input type="checkbox" data-stemp-checked="_value" /></li>
			</div>
		</div>
	</div>
</div>

These are two templates that will get loaded at runtime. When DataStamp loads them, it merges new nodes from the later templates into the original template, so we'll end with a dom node that's not rendered on the page, but has three nodes at the _default_entity level.

	runtime = new JEFRi.Runtime "testContext.json"
	init = JEFRi.Template.init
		templates: ["../src/template.html", "./testTemplates.html"]

	_.when(runtime.ready, init).done ->
		user = runtime.build("User", {name: "southerd", address: "davidsouther@gmail.com"}
		view = JEFRi.Template.renderuser
		view.appendTo "#templates-target"
